---
layout:     post   				          # 使用的布局（不需要改）
title:      Linux 常用命令（二）			# 标题 
subtitle:   三种强大的文本处理工具                #副标题
date:       2018-04-15			      # 时间
author:     Mr.Children						# 作者
header-img: img/1.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - Linux
---
### 一. grep 的使用(正则表达式的使用)
正则表达式的匹配规则
![](https://ws1.sinaimg.cn/large/8aa6de51ly1fr8wvt00c4j20jb1r347n.jpg)
```
grep '^http' test.txt		#获取以http开头的行
grep '[0-9]' test.txt			#获取包含数字的行
grep '^$' test.txt			#获取空行^,$分别为行的开头和结尾
grep 'html$' test.txt		#获取html结尾的行
grep 'w[^ ]*.html' test.txt	#限定中间不能有空格
grep 'w...html' test.txt		#中间只能有两个字符
grep 'w.{2}.html' test.txt	#中间只能有两个字符
##########################################################
grep -v 'jiangjun' test.txt		#排除某些行
grep -n 'jiangjun' test.txt		#显示匹配的行以及行号
grep -n '.' test.txt				#显示所有行的行号
grep -i 'jiangjun' test.txt		#不区分大小写的过滤内容
grep -Ei 'jiangjun' test.txt		#同时过滤多个字符
grep -c 'jiangjun' test.txt		#只统计匹配的行数
grep -o 'jiangjun' test.txt		#只输出匹配的内容
grep -w 'jiangjun' test.txt		#只匹配过滤的单词
grep -Ev '^$|#' test.txt			#去除里面的空行和注释
```

### 二. awk  的使用
awk擅长对文件按行操作,每次读取一行,然后进行相应的操作  
**读取单个文件的基本格式是:**  
`awk 'BEGIN{OFS=FS="\t"}'{print $0,$1;}' filename`  
**读取多个文件时的基本格式是:**  
`awk 'BEGIN{OFS=FS="\t"} ARGIND==1 {print $0, $1;}ARGIND==2 {print $0;}' file1 file2`

- OFS: 文件输出时的列分隔符 (output field separtor)
- FS: 文件输入时的列分隔符 (field separtor)
- BEGIN: 设置初始参数,初始化变量
- END: 读完文件后做最终的处理
- 其它 {}:循环读取文件的每一行
- $0 表示一行内容;$1, $2, ... $NF 表示第一列,第二列到最后一列。
- NF (number of fields) 文件多少列;NR (number of rows) 文件读了多少行: FNR 当前文件读了多少行,常用于多文件操作时
- a[$1]=1: 索引操作,类似于 python 中的字典,在 ID map,统计中有很多应用
#### 常见操作
##### 基本使用
```
awk 'NR==5' test.txt		#显示第五行的内容
awk 'NR==2 NR==6' test.txt		#显示2-6行的内容
awk '{print NR,$0}' test.txt			#为每一行添加行号
awk -F ":" '{print $1,$3,$NF}' test.txt		#分别打印三个部分的内容
awk 'NR%2==0' test.txt		#输出偶数行
awk 'NR%2==1' test.txt		#输出奇数行
```
##### 针对特定列的计算,比如wig 文件的标准化
```
#第一行是空格,其他行都是tab 键分割开来
vim wei.wig
variableStep chrom=chr2
300701	12
300702	10
300703	11
300704	13
300705 	12.5
awk 'BEGIN{OFS=FS="\t"}{if(FNR>1) $2=$2*10^6/(2.5*10^6); print $0}' wei.wig 
variableStep chrom=chr2
300701	4.8
300702	4
300703	4.4
300704	5.2
300705	5
```
##### 计算某列内容出现的次数
```
vim count
ID	Type
Pou5f1	Pluripotency
Nanog	Pluripotency
Sox2	Neuron
Tet1	Epigenetic
Tet3	Epigenetic
Myc	Oncogene
awk 'BEGIN{OFS=FS="\t"}{if(FNR>1) a[$2]+=1;}END{print "Type\tcount"; for (i in a) print i,a[i];}' count
Type	count
Oncogene	1
Epigenetic	2
Pluripotency	2
Neuron	1
```
##### 从GTF文件中提取启动子区域
原始文件[Homo_sapiens.GRCh38.91.gtf](ftp://ftp.ensembl.org/pub/release-91/gtf/homo_sapiens/Homo_sapiens.GRCh38.91.gtf.gz)
```
sed "s/''/\t/g" Homo_sapiens.GRCh38.91.gtf |  
awk 'BEGIN{OFS=FS="\t"}{if($3=="gene") {ensn=$10; symbol=$16; if($7=="+") {start=$4-1;up=start-1000; if(up<0) up=0; dw=start+500; print $1,up, dw, ensn, symbol, $7;} else if($7=="-") {start=$5-1; up=start+1000; dw=start-500; if(dw<0) dw=0; print $1,dw,up,ensn,symbol,$7}}}' |sort -k1,1 -k2,2n > GRCh38.promoter.bed
```
##### 数据矩阵的格式化输出
```
vim numeric.matrix
ID      A       B       C
a       1.002   1.234   1.999
b       2.333   4.232   0.889
awk '{if(FNR==1) print $0; else {printf "%s%s",$1,FS; for (i=2; i<=NF; i++) printf "%.1f %s", $i, (i==NF?RS:FS)}}' numeric.matrix
```
##### 判断FASTQ文件中,输出质量值的长度与序列长度不一致的序列ID
```
cat << END | gzip -c > Test_2.fq.gz
>fio1
ACGTCGACGACGAGAGGAGAGGAGCCCTCTCGCCCGCCCTACTACCACCCACACACAACACAAGTGT
+
FFFFFFA$A#$$AFEEEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
>fio2
ACGTCGACGACGAGAGGAGAGGAGCCCTCTCGCCCGCCCTACTACCACCCACACACAACACAAGTGT
+
FFFFFF$A#$$AFEEEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
>fio3
ACGTCGACGACGAGAGGAGAGGAGCCTCTCGCCCGCCCTACTACCACCCACACACAACACAAGTGT
+
FFFFFFA$A#$$AFEEEEFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
END
zcat Test_2.fq.gz | \
awk '{if(FNR%4==1) ID=$0; else if(FNR%4==2) seq_len=length($0); \
else if(FNR%4==0) {quality_len=length($0); if(seq_len!=quality_len) print ID; }}'
```
##### 筛选差异基因
```
vim de_gene
ID	log2fc	padj
A	1	0.001
B	-1 	0.001
C	1	0.001
D	2	0.0001
E	-0.51	0.051
F	0.1	0.1
G	1	0.1
awk '$3<0.05 || NR==1' de_gene
awk 'BEGIN{OFS=FS="\t"}{if(FNR==1) print $0; \
else {abs_log2fc=($2<0?$2*(-1):$2);if(abs_log2fc>=1 && $3<0.05) print $0;}}' de_gene
```
##### 筛选差异基因存储到不同的文件
```
awk 'BEGIN{OFS=FS="\t"; up="up"; dw="dw";}\
{if(FNR==1) {print $0 >up; print $0 >dw;} else \
if ($3<0.05) {if ($2>=1) print $0 >up; else if($2<=-1) print $0 >dw;}}' de_gene
head up dw
#自动版
awk 'BEGIN{OFS=FS="\t"; up=ARGV[1]".up"; dw=ARGV[1]".dw";}\
{if(FNR==1) {print $0 >up; print $0 >dw;}
else if ($3<=0.05) {if($2<=-1) print $0 >up; else if ($2>=1) print $0 >dw;}}' de_gene
```
##### ID map,长用于转换序列的ID,提取信息,合并信息
```
vim id_map
ENSM	Symbol	Entrez
ENSG00000280516	TMEM42	693149
ENSG00000281886	TGM4	7047
ENSG00000280873	DGKD	8527
ENSG00000281244 	ADAMTS13	11093
ENSG00000280701	RP11-272D20.2
ENSG00000280674	ZDHHC3	51304
ENSG00000281623	Y_RNA
ENSG00000280479	CACFD1	11094
ENSG00000281165	SLC2A6	11182
ENSG00000281879	ABO	28
ENSG00000282873	BCL7A	605
ENSG00000280651	AC156455.1	100506691
vim ensm
ENSG00000281244
ENSG00000281165
ENSG00000282873
awk 'BEGIN{OFS=FS="\t"}ARGIND==1{if(FNR>1) ensm2entrez[$1]=$3;}\
ARGIND==2 {print ensm2entrez[$1];}' id_map ensm
```
##### 数值操作
```
awk 'BEGIN{OFS="\t";FS="\t"}{print log($0)/log(2)}' file		#取对数
awk 'BEGIN{OFS="\t";FS="\t"}{print int($1+0.5);}' file			#取整,四舍五入
```
### 三. sed 的使用
```
sed 's/;/\t/g' test.txt
ID;2 cell;4 cell;8 cell;embryo
Pou5f1_1;2;3;4;5
Nanog_1;2;3.2;4.3;5
c-Myc;2;3;4;5
Tet1_3;2;3;4;5
sed "s/''/\t/g" test.txt		#替换
sed "s/ /_/" test.txt		#一次替换
sed "s/ /_/g" test.txt		#全部替换
echo `seq 1 10` | sed 's/ /,/g'		#获得逗号分割的一组数
sed '2,$ s/_[0-9]//g' test.txt		#针对指定行的替换
sed 's/ /_/1' test.txt				#替换第一个空格
sed 's/ /_/2' test.txt				#替换第二个空格
sed 's/ /_/2g' test.txt				#替换第二个以及以后的空格
vim seq 
ACDGTFGGCATGCDTGD
ACDGAGCDTAGCDGTA
CAGDTAGDCTADTG
sed = seq		#给序列起名字
sed = seq | sed 'N;s/^/>/;'		#同时缓冲两行,但是只对第一行行首操作
#给文件增加标题行
tail -n +2 test.txt | sort -k2,2n|sed '1 i ID\t2_cell\t4_cell\t8_cell\tembryo'
sed -n '2,4p' test.txt		#输出第二到第四行
sed -n '/_/p' test.txt		#普通字符串和正则表达式都支持	
sed '/^$/d' test.txt			#删除空行
sed '2,3d' test.txt			#删除指定的行
sed '1~2d' test.txt			#偶数行
sed '1~2!d' test.txt			#奇数行
```